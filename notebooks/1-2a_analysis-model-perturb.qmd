---
jupyter: python3
---

# Analysis of plant perturbations

In this notebook we begin our analysis of the models trained in the presence of different levels of curl force fields:

- examine differences in baseline performance and state profiles of the models; e.g. differences in velocity profiles
- compare robustness to mechanical disturbances; e.g. differences in endpoint error when subject to large curl fields; 


## Environment setup

```{python}
%load_ext autoreload
%autoreload 2
```

```{python}
import os

os.environ["TF_CUDNN_DETERMINISTIC"] = "1"
```

```{python}
from functools import partial
from itertools import zip_longest
from pathlib import Path
from operator import itemgetter

import equinox as eqx
import jax
import jax.numpy as jnp
import jax.random as jr
import jax.tree as jt
import matplotlib.pyplot as plt

from feedbax import (
    load_with_hyperparameters, 
    is_module, 
    tree_take, 
    tree_take_multi,
)
from feedbax.intervene import CurlField, schedule_intervenor
from feedbax.misc import git_commit_id, attr_str_tree_to_where_func
from feedbax.noise import replace_noise
import feedbax.plotly as fbp
from feedbax.task import SimpleReaches
from feedbax.xabdeef.losses import simple_reach_loss

from rnns_learn_robust_motor_policies.part1_setup import setup_models, setup_model_parameter_histories
from rnns_learn_robust_motor_policies.plot_utils import get_savefig_func
from rnns_learn_robust_motor_policies.tree_utils import swap_model_trainables

```

Log the library versions and the feedbax commit ID, so they appear in any reports generated from this notebook.

```{python}
for mod in (jax, eqx): 
    print(f"{mod.__name__} version: {mod.__version__}")
    
print(f"\nFeedbax commit hash: {git_commit_id()}")
```


### Global conditions

```{python}
NO_SYSTEM_NOISE = False

if NO_SYSTEM_NOISE:
    fig_suffix = "_no-noise"
else:
    fig_suffix = ""
```

### Directories setup

```{python}
FIGS_DIR = Path('../figures/1-2a/')
MODELS_DIR = Path('../models')

for d in (FIGS_DIR,):
    d.mkdir(parents=True, exist_ok=True)
    
if not MODELS_DIR.exists():
    raise FileNotFoundError(f"Models directory not found: {MODELS_DIR.absolute()}")
```

### Plotting setup 

```{python}
trials_cmap = 'viridis'  # for trials
trials_cmap_func = plt.get_cmap(trials_cmap)

savefig = get_savefig_func(FIGS_DIR)
```

### RNG setup

```{python}
SEED = 5566
key = jr.PRNGKey(SEED)
key_init, key_train, key_eval = jr.split(key, 3)
```


## Load trained models

```{python}
models_save_filename = "1-1_trained_models.eqx"
models_parameter_history_filename = "1-1_model_parameter_histories.eqx"

trained_models, hyperparameters = load_with_hyperparameters(
    MODELS_DIR / models_save_filename, setup_models,
)

if NO_SYSTEM_NOISE:
    trained_models = replace_noise(trained_models)

curl_stds = hyperparameters['disturbance_levels']
trained_models = dict(zip(curl_stds, trained_models))
```

Depending on how training goes, we might want to leave out some of the extreme curl strength training conditions.

```{python}
# curl_stds = curl_stds[:-2]

trained_models = {key: trained_models[key] for key in curl_stds}
```

### Load parameters from earlier training iterations, where necessary

Also depending on how training goes, we might want to keep the model parameters from an earlier training iteration.

```{python}
model_parameter_histories, train_hyperparameters = load_with_hyperparameters(
    MODELS_DIR / models_parameter_history_filename,
    partial(setup_model_parameter_histories, list(trained_models.values())),
)

model_parameter_histories = dict(zip(curl_stds, model_parameter_histories))
where_train = attr_str_tree_to_where_func(train_hyperparameters['where_train_strs'])

load_spec = {0.4: -1, 0.5: -1}

for curl_std, i in load_spec.items():
    trained_models[curl_std] = swap_model_trainables(
        trained_models[curl_std], tree_take(model_parameter_histories[curl_std], i), where_train
    )
```

## Compare behaviour on unperturbed reaches

### Set up unperturbed reach task

We will generally evaluate on a 2*2 grid of center-out reach sets, with 32 reach directions per set. 

This is to ensure good coverage and a larger set of conditions/trials on which to perform statistics. 

In the case of visualization of center-out sets, we'll use a smaller version of the task with only a single set of 7 reaches -- an odd number helps with visualization sometimes.

```{python}
n_steps = 100
workspace = ((-1., -1.),
             (1., 1.))

task = SimpleReaches(
    loss_func=simple_reach_loss(),
    workspace=workspace, 
    n_steps=n_steps,
    eval_grid_n=2,  
    eval_n_directions=32,  
    eval_reach_length=0.3,    
)

# Make a smaller version of the task for visualization.
task_small = eqx.tree_at(
    lambda task: (
        task.eval_grid_n,
        task.eval_n_directions,
        task.eval_reach_length,
    ),
    task, 
    (1, 7, 0.5)
)
``` 

### Evaluate the trained models on the unperturbed reach task

Evaluate each condition (reach direction) several times, to see how performance varies with noise.

```{python}
n_trials = 2

keys_eval = jr.split(key_eval, n_trials)
```

Now for each trained ensemble of models, evaluate each model in the ensemble on `n_trials` repetitions of each of the `eval_n_directions` reach directions. 

Note:

1. Set `ensemble_random_trials=False` so that each model in the ensemble will be evaluated on the same set of trials. 
2. Vmap over `keys_eval`, to obtain `n_trials` different evaluations of the center-out set. 
3. Use `jt.map` to repeat for each training condition (entry in `trained_models`).

```{python}
def get_eval_ensemble(models, task):
    def eval_ensemble(key):
        return task.eval_ensemble(
            models,
            n_replicates=hyperparameters['n_replicates'],
            ensemble_random_trials=False,
            key=key,
        )
    return eval_ensemble

states_control = jt.map(
    lambda models: eqx.filter_vmap(get_eval_ensemble(models, task))(keys_eval),
    trained_models,
    is_leaf=is_module,
)

states_control_small = jt.map(
    lambda models: eqx.filter_vmap(get_eval_ensemble(models, task_small))(keys_eval),
    trained_models,
    is_leaf=is_module,
)
```

Each state array in `states` has the following batch dimensions: `(n_trials, n_replicates, n_conditions, n_steps)`. 

For a single center-out set, `n_conditions = eval_n_directions`. But if `eval_grid_n != 1`, then there will be `eval_grid_n ** 2` center-out sets and the third dimension will have size `eval_n_directions * eval_grid_n ** 2`.

We can average over several different dimensions:

1. Trials per reach direction.
2. Reach directions; these should be similar because the task and biomechanics are isotropic.
3. Replicates.

### Plot all the trials for an example replicate, for each training condition

Training condition = set of trained models/entry in `trained_models`.

Note that we use `states_control_small` here, and only plot a single center-out set of 7 reach directions.

```{python}
i_replicate = 0
```

A single trial:

```{python}
i_trial = 0

figs = jt.map(
    lambda states: fbp.effector_trajectories(
        tree_take_multi(states, [i_trial, i_replicate], [0, 1]),
        trial_specs=task_small.validation_trials,
    ),
    states_control_small,
    is_leaf=is_module,
)

for curl_std, fig in figs.items():
    savefig(fig, f"control_curl-std-{curl_std}_single-replicat-{i_replicate}_single-trial")
```

All trials:

```{python}
figs = jt.map(
    lambda states: fbp.effector_trajectories(
        tree_take_multi(states, [i_replicate], [1]),
        trial_specs=task_small.validation_trials,
        mode='lines',
        trace_kwargs=dict(line_width=0.5),
    ),
    states_control_small,
    is_leaf=is_module,
)

figs[0].show()

for curl_std, fig in figs.items():
    savefig(fig, f"control_curl-std-{curl_std}_single-replicate-{i_replicate}_all-trials")
```

### Compare the mean velocity profiles

Average over trials, directions, and replicates to get an average velocity profile + error bands for each training condition. 

Note that it only makes sense to compare across reach directions if we consider the velocity profiles along the respective directions. For example, the y-profile in one direction should be comparable to the x-profile in an orthogonal direction.

There are two ways we might get profiles for comparison.

1. Calculate speed as the magnitude of the velocity vector. This is simpler.
2. Project the velocity profiles onto the reach direction.

These are not identical, and the second method is more flexible because we still retain the components and their signs. 

First, the speed profiles:

**TODO: matplotlib**

```{python}
speeds_control = jt.map(
    lambda states: jnp.linalg.norm(states.mechanics.effector.vel, axis=-1),
    states_control,
    is_leaf=is_module,
)

fig = fbp.profiles_mean(speeds_control, varname="Speed")
fig.show()
savefig(fig, "control_mean-speeds")
```

And the projected profiles:

```{python}
from feedbax import tree_unzip
from rnns_learn_robust_motor_policies.state_utils import forward_lateral_vels

forward_vels, lateral_vels = tree_unzip(jt.map(
    lambda state: forward_lateral_vels(state.mechanics.effector.vel, task.validation_trials),
    states_control,
    is_leaf=is_module,
))
```

```{python}
fig = fbp.profiles_mean(forward_vels, varname="Forward velocity")
fig.show()
savefig(fig, "control_mean-forward-vels")

fig = fbp.profiles_mean(lateral_vels, varname="Lateral velocity")
fig.show()
savefig(fig, "control_mean-lateral-vels")
```

## Compare behaviour on perturbed reaches

### Set up perturbed reach tasks

Over a range of strengths.

```{python}
curl_amplitudes_test = [0.1, 0.5, 1.0]

tasks_curl, _ = tree_unzip(jt.map(
    lambda curl_amplitude: schedule_intervenor(
        task, trained_models[0],
        lambda model: model.step.mechanics,
        CurlField.with_params(amplitude=curl_amplitude),
        # The trained models already have a `CurlField` intervenor, so we can just 
        # alter the task with an intervenor of the same label, and discard the modified 
        # model returned by `schedule_intervenor`.
        label="CurlField",
        default_active=False,
    ),
    dict(zip(curl_amplitudes_test, curl_amplitudes_test)),
))

# Make a smaller version of the task for visualization.
tasks_curl_small = jt.map(
    lambda task: eqx.tree_at(
        lambda task: (
            task.eval_grid_n,
            task.eval_n_directions,
            task.eval_reach_length,
        ),
        task, 
        (1, 7, 0.5),
    ),
    tasks_curl,
    is_leaf=is_module,
)
```

### Evaluate the trained models on the perturbed reach tasks

For a 2*2  grid of 32-direction center-out reach sets, 10 replicates, and 5 trials per reach, evaluating each task variant leads to approximately 1.5 GB of states. 

Thus we either need to:

- limit the number of task variants (i.e. `len(curl_stds_test)`);
- reduce the number of validation reaches; 
- do this on CPU (assuming we have more RAM available);

```{python}
all_states_pert = jt.map(
    lambda task: jt.map(
        lambda models: eqx.filter_vmap(get_eval_ensemble(models, task))(keys_eval),
        trained_models,
        is_leaf=is_module,
    ),
    tasks_curl,
    is_leaf=is_module,
)

all_states_pert_small = jt.map(
    lambda task: jt.map(
        lambda models: eqx.filter_vmap(get_eval_ensemble(models, task))(keys_eval),
        trained_models,
        is_leaf=is_module,
    ),
    tasks_curl_small,
    is_leaf=is_module,
)
```

The result is a dict whose keys are the `curl_stds_test`, and whose values are dicts whose keys are the `curl_stds` used in training, and whose values are the state objects.

```{python}
eqx.tree_pprint(all_states_pert, truncate_leaf=is_module)
```

TODO: Instead of a two-layer `jt.map`, we could instead define a function (to schedule the intervenor given a `curl_std` and then `jt.map` the vmapped `eval_ensemble`) and then vmap it over `curl_stds_test` to get a single-level dict with a bit less overhead.

### Single-condition comparison of 2D trajectories

Multiple trials or replicates, but for a single reach direction: show how training on different curl strengths affects response.

```{python}
i_direction = 0

figs = jt.map(
    lambda states: fbp.effector_trajectories(
        tree_take_multi(states, [i_replicate], [1]),
        where_data=lambda state: state.mechanics.effector.pos,
        trial_specs=task_small.validation_trials,
        mode='lines',
        trace_kwargs=dict(line_width=0.5),
    ),
    all_states_pert_small,
    is_leaf=is_module,
)
```

```{python}
var_labels = ('Position', 'Velocity')

where_plot = lambda states: (
    states.mechanics.effector.pos,
    states.mechanics.effector.vel,
    # states.efferent.output,
)
```

Using the new plotting function for the full center-out set, for a single replicate:

```{python}
plot_states = tree_take_multi(all_states_pert_small, [i_replicate], [1])

figs = jt.map(
    lambda states: fbp.trajectories_2D(
        where_plot(states),
        var_labels=var_labels,
        axes_labels=('x', 'y'),
        mode='lines',
        # colorscale_axis=0,
        trace_kws=dict(line_width=1),
    ),
    plot_states,
    is_leaf=is_module,
)
```

And for a single reach direction:

```{python}
i_condition = 0

plot_states = tree_take_multi(all_states_pert_small, [i_replicate, i_condition], [1, 2])
```

```{python}
figs = jt.map(
    lambda states: fbp.trajectories_2D(
        where_plot(states),
        var_labels=var_labels,
        axes_labels=('x', 'y'),
        mode='lines',
        colorscale_axis=1,
        trace_kws=dict(line_width=1),
    ),
    plot_states,
    is_leaf=is_module,
)
```

Now one plot for all the test curl magnitudes, for each training condition:

```{python}
from feedbax import tree_stack

plot_states_ = tree_stack(plot_states.values())

figs = jt.map(
    lambda states: fbp.trajectories_2D(
        where_plot(states),
        var_labels=var_labels,
        axes_labels=('x', 'y'),
        mode='lines',
        colorscale_axis=0,
        trace_kws=dict(line_width=1),
    ),
    plot_states_,
    is_leaf=is_module,
)
```

And one plot for all the training conditions, for each single test curl magnitude:

TODO: use curl std to label the legend entries

```{python}
plot_states_ = {
    test_curl_mag: tree_stack(s.values())
    for test_curl_mag, s in plot_states.items()
}

figs = jt.map(
    lambda states: fbp.trajectories_2D(
        where_plot(states),
        var_labels=var_labels,
        axes_labels=('x', 'y'),
        mode='lines',
        colorscale_axis=0,
        scatter_kws=dict(line_width=1),
    ),
    plot_states_,
    is_leaf=is_module,
)

figs[0.5].show()
```

### Compare mean forward and lateral velocity profiles



## Summary comparison of performance measures 

i.e. Box plots. 

- Max speed
- Max forward velocity
- Max lateral velocity
- Max lateral deviations
- Summed deviations
- Endpoint error (final deviation/mean over last N steps)






