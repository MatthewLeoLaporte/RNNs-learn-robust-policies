Note how `AbstractAnalysis` is structured. This allows use to write analysis modules like `unit_perts` which specify `ALL_ANALYSES` as essentially a declarative sequence of analyses to perform. However, the way it is currently structured feels limiting in some cases, and I am not sure if this is because it is actually limiting or just because I am not totally accustomed to it. Note that the `dependencies` field of `AbstractAnalysis` is a `ClassVar`, which means that we need to hardcode the dependencies into a given subclass. 

Perhaps some analyses may be quite general (e.g. PCA, or a regression analysis) and thus their inputs would not necessarily come from such a specific node type in the computation graph. We could make `dependencies` a field rather than a `ClassVar`, but this might raise other issues. For example, currently, the dependencies are wrangled in `execution`/`_dependencies` and provided to the `compute` and `make_figs` methods as kwargs; thus e.g. in `Profiles` we can add the kwarg `vars` to the signature of `make_figs` since `vars=AlignedVars` is in `dependencies`. However, if we wanted to make `dependencies` a field where the keys might be defined arbitrarily by the user, then how would those dependencies be uniquely identified in the body of `compute`/`make_figs`? It seems like we might need a class var which defines the shape/number and name of input "ports" of the analysis, and some other way to define the actual edges of the computation graph (i.e. which ports connect to which).

Likewise, maybe the current declarative approach is not ideal, and instead we should be using some kind of scheme where the user defines the computation graph of modular elements (i.e. the AbstractAnalysis subclasses), maybe as a function `main` or something instead of a sequence `ALL_ANALYSES`. I have a lot of uncertainty here so you should not anchor on my suggestions whatsoever, but try to think about best practices and elegance and so on.

At this point I have more practical things to worry about and I would like a minimal refactoring that would solve the dependency hard-coding problem without requiring a total rewrite of much of my project structure. If there is some way to retain the current declarative structure while also allowing the computational graph to be set up more explicitly, that might be ideal. 

Here is my best idea about how to do this, though if you think there is a more elegant alternative, you are welcome to describe it. 

1) `ALL_ANALYSES` could be a `dict` where the keys uniquely identify the analysis instances in a submodule, 2) each `AbstractAnalysis` subclass has a ClassVar(s) that defines named ports as well as their default dependencies (as `type[AbstractAnalysis]`), 3) when instantiating an analysis in `ALL_ANALYSES`, we can pass a dependency dict with maps port names to the keys of other analyses defined in `ALL_ANALYSES`, *or* analyses which are defined in a new `DEPENDENCIES: dict` in each analysis module. (The difference between `ALL_ANALYSES` and `DEPENDENCIES` is simply that analyses in `DEPENDENCIES` will not have their `make_figs` methods run, nor the results of their `compute` methods included in the `all_results` that is returned to the user.) 

More notes:

- All subclasses of `equinox.Module` are dataclasses, so you should not add `__init__` method to `AbstractAnalysis` or any of its subclasses.
- We should not need to modify the bodies of `make_figs` or `compute` methods in subclasses. The name of the input port should be available as a kwarg to these methods as it already was. For example, in `Profiles`, the `"vars"` port should be accessible by adding `vars` to the signature of those methods.
- I do not think it makes sense to simply convert `dependencies` from a ClassVar to a field such as `custom_dependencies`. If we were to use this field to specify the class dependencies with their defaults, then if the user passes `custom_dependencies=...` when instantiating, they would (need to) override the entire field, and thus the defaults for *all* the input ports. But actually the user should be able to pass a subset of analyses to map to ports, and keep the defaults for the other ports. This suggests there should be something like a `inputs: ClassVar` that defines the port spec/defaults separately.
- When passing custom dependencies, presumably they would be assigned to a field of type `Mapping[str, str | AbstractAnalysis]`, i.e. with a string value indicating an entry in `ALL_ANALYSES` or `DEPENDENCIES`, and an `AbstractAnalysis` value being a direct reference to some instance (e.g. constructed in-place in `ALL_ANALYSES). If it does not make sense according to the present dependency handling to pass instances directly like that, then please very briefly justify why it doesn't make sense to pass instances; then, you can use type `Mapping[str, str]` for the field.
- It is unnecessary to keep `dependency_params` if we can now pass references to custom analysis objects. If the default dependencies are used, they can be instantiated with their default parameters as they already are when `dependency_params` is unspecified.
- Keep `dependency_kwargs` as is, for now, since a subclass may need to define how to instantiate its dependencies in terms of `self`.
- The `label` field can be removed from `AbstractAnalysis`, and the key in `ALL_ANALYSES` used in its place. It should be unnecessary to store this info in the analysis instance; the logic in `id_str` property can be moved outside of `AbstractAnalysis` as it will not have access to the analysis key. In places where an analysis is uniquely identified or labeled by its parameters/fields, the contents of `custom_dependencies` should also be included, since they determine the analysis.
- Not all dependencies of an analysis subclass are "ports". For example, `data.states` can be processed by prep ops. Thus please be careful about how you modify `_get_target_dependency_names`, if that is even necessary.
- I am concerned that allowing dependencies to be included in `ALL_ANALYSES` (i.e. when we want one analysis to depend on another, and we want to generate figures for both of them) will obviate the distinction between analyses that are evaluated in `compute_dependencies`, and those that are evaluated "as" analyses in `analyse_and_save`. So perhaps `compute_dependencies` should compute results for the *entire* computation graph, including the leaf analyses in `ALL_ANALYSES`; and perhaps it should be called `compute_all_results`.
- Keep in mind that instances of `equinox.Module` (and thus `AbstractAnalysis`) are *frozen* (immutable) dataclasses. 

Do not make any more changes to than are minimally necessary to achieve the indicated results. Do not remove comments or rename existing variables. Do not edit code merely to add comments. Do not introduce new unrequested features or checks, however minor. Do not refactor things that are not absolutely necessary to refactor to achieve the goal. Do not rename arguments based on changes to their type; e.g. `some_argument` should not become `some_argument_dict` -- the difference will be clear in their changed annotations.

Do not attempt to run the modified code.